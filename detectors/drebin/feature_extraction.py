import os
import sys
import time
import warnings
import multiprocessing
from pprint import pprint
import re
import collections

import numpy as np

from androguard.misc import APK, AnalyzeAPK
import lxml.etree as etree
from xml.dom import minidom

from tools import utils
from tools import progressbar_wrapper

current_dir = os.path.dirname(os.path.realpath(__file__))
from sys import platform as _platform

if _platform == "linux" or _platform == "linux2":
    TMP_DIR = '/tmp/drod_xml_files/'
elif _platform == "win32" or _platform == "win64":
    TMP_DIR = 'C:\\TEMP\\'

# information about feature extraction
SuspiciousNames = ["getExternalStorageDirectory", "getSimCountryIso", "execHttpRequest",
                   "sendTextMessage", "getPackageInfo", "getSystemService",
                   "setWifiDisabled", "Cipher",
                   "Ljava/net/HttpURLconnection;->setRequestMethod(Ljava/lang/String;)",
                   "Ljava/io/IOException;->printStackTrace",
                   "Ljava/lang/Runtime;->exec",
                   "system/bin/su"
                   ]


def get_vocabulary(feature_list):
    """
    obtain the vocabulary based on the features
    :param feature_list: 2D list of naive features
    :return: feature vocabulary
    """
    c = collections.Counter()

    for features in feature_list:
        for feature in features:
            c[feature] = c[feature] + 1

    vocab, count = zip(*c.items())
    return list(vocab)


def feature_selection(train_features, train_y, vocab, dim):
    """
    feature selection
    :param train_features: 2D features
    :type numpy object
    :param train_y: ground truth labels
    :param vocab: a list of words (i.e., a feature)
    :param dim: the remained number of words
    :return: chose vocab
    """
    is_malware = (train_y == 1)
    mal_features = np.array(train_features)[is_malware]
    ben_features = np.array(train_features)[~is_malware]

    if (len(mal_features) <= 0) or (len(ben_features) <= 0):
        return vocab

    mal_representations = get_feature_representation(mal_features, vocab)
    mal_frequency = np.sum(mal_representations, axis=0) / float(len(mal_features))
    ben_representations = get_feature_representation(ben_features, vocab)
    ben_frequency = np.sum(ben_representations, axis=0) / float(len(ben_features))

    # eliminate the words showing zero occurrence in apk files
    is_null_feature = np.all(mal_representations == 0, axis=0) & np.all(ben_representations, axis=0)
    vocab_filtered = list(np.array(vocab)[~is_null_feature])

    if len(vocab_filtered) <= dim:
        return vocab_filtered
    else:
        feature_frq_diff = np.abs(mal_frequency[~is_null_feature] - ben_frequency[~is_null_feature])
        position_flag = np.argsort(feature_frq_diff)[::-1][:dim]

        vocab_selected = []
        for p in position_flag:
            vocab_selected.append(vocab_filtered[p])
        return vocab_selected


def get_feature_representation(feature_list, vocab):
    """
    mapping feature to numerical representation
    :param feature_list: 2D feature list with shape [number of files, number of features]
    :param vocab: a list of words
    :return: 2D representation
    :rtype numpy.ndarray
    """

    N = len(feature_list)
    M = len(vocab)

    assert N > 0 and M > 0

    representations = np.zeros((N, M), dtype=np.float32)
    dictionary = dict(zip(vocab, range(len(vocab))))
    for i, features in enumerate(feature_list):
        if len(features) > 0:
            filled_positions = [idx for idx in list(map(dictionary.get, features)) if idx is not None]
            if len(filled_positions) != 0:
                representations[i, filled_positions] = 1.
            else:
                warnings.warn("Produce zero feature vector.")

    return representations


def feature_extraction(sample_dir, backup_path=None, proc_number=2):
    """
    extract drebin features for apks
    :param sample_dir: a folder contains apk files
    :param backup_path: save the meta-information into this path if provided.
    :param proc_number: the number of core
    :return: a list of features correspond to the samples in the given path
    """
    if not isinstance(sample_dir, str) and not isinstance(sample_dir, list):
        MSG = "A directory or a list of path is allowed!"
        raise ValueError(MSG)

    if isinstance(sample_dir, str):
        if not os.path.exists(sample_dir):
            MSG = "No such directory or file {} exists!".format(sample_dir)
            raise ValueError(MSG)
        elif os.path.isfile(sample_dir):
            sample_path_list = [sample_dir]
        elif os.path.isdir(sample_dir):
            sample_path_list = list(utils.retrive_files_set(sample_dir, "", ".apk|"))
            assert len(sample_path_list) > 0, 'No files'
        else:
            raise ValueError(" No such path {}".format(sample_dir))

    if isinstance(sample_dir, list):
        sample_path_list = sample_dir

    if backup_path is None:
        backup_path = os.path.join(TMP_DIR, 'backup_data')
    utils.mkdir(backup_path)

    pool = multiprocessing.Pool(int(proc_number))
    pbar = progressbar_wrapper.ProgressBar()
    process_results = []
    tasks = []
    result_paths = []
    pmap = AxplorerMapping()

    for i, apk_path in enumerate(sample_path_list):
        sample_name = os.path.splitext(os.path.basename(apk_path))[0]
        back_path_name = os.path.join(backup_path, sample_name + '.data')
        if os.path.exists(back_path_name):
            result_paths.append(back_path_name)
            continue
        tasks.append(apk_path)
        process_results = pool.apply_async(get_drebin_feature,
                                           args=(apk_path, pmap, back_path_name),
                                           callback=pbar.CallbackForProgressBar)

    pool.close()
    if process_results:
        pbar.DisplayProgressBar(process_results, len(tasks), type='hour')
    pool.join()

    for i, res in enumerate(pbar.TotalResults):
        status, res_path = res
        if status:
            result_paths.append(res_path)

    feature_list = []
    for res_path in result_paths:
        features = utils.read_txt(res_path)
        feature_list.append(features)

    return feature_list


def get_drebin_feature(apk_path, pmap, save_path):
    """
    produce `drebin' feature (dumped as a .data file) for a give path
    :param apk_path: an absolute path of an apk file
    :param pmap: api mapping class
    :param save_path: a folder (absolute path) for saving .data files
    :return: True or False,  `True' means conducting feature extraction successfully
    """
    try:
        print("Processing " + apk_path)
        start_time = time.time()
        data_dict = {}

        requested_permission_list, \
        activity_list, \
        service_list, \
        content_provider_list, \
        broadcast_receiver_list, \
        hardware_list, \
        intentfilter_list = get_feature_xml(apk_path)

        used_permission_list, \
        restricted_api_list, \
        suspicious_api_list, \
        url_list = get_feature_dex(apk_path, pmap, requested_permission_list)

        data_dict['requested_permission_list'] = requested_permission_list
        data_dict['activity_list'] = activity_list
        data_dict['service_list'] = service_list
        data_dict['content_provider_list'] = content_provider_list
        data_dict['broadcast_receiver_list'] = broadcast_receiver_list
        data_dict['hardware_list'] = hardware_list
        data_dict['broadcast_receiver_list'] = broadcast_receiver_list
        data_dict['hardware_list'] = hardware_list
        data_dict['intentfilter_list'] = intentfilter_list
        data_dict['used_permission_list'] = used_permission_list
        data_dict['restricted_api_list'] = restricted_api_list
        data_dict['suspicious_api_list'] = suspicious_api_list
        data_dict['url_list'] = url_list

        # features = sum(
        #     [list(map(lambda elem_str: head_str + elem_str, body_list)) \
        #      for head_str, body_list in data_dict.items()],
        #     [])

        # dump the features
        dump_feature(save_path, data_dict)
    except Exception as e:
        end_time = time.time()
        print("Fail to process " + apk_path + " during the time " + str(end_time - start_time))
        print(str(e))
        return False, save_path
    else:
        end_time = time.time()
        print("Success to process " + apk_path + " during the time " + str(end_time - start_time))
        return True, save_path


def get_feature_xml(apk_path):
    """
    get requested features from manifest file
    :param apk_path: absolute path of an apk file
    :return: tuple of lists
    """
    requested_permission_list = []
    activity_list = []
    service_list = []
    content_provider_list = []
    broadcast_receiver_list = []
    hardware_list = []
    intentfilter_list = []
    xml_tmp_dir = os.path.join(TMP_DIR, 'xml_dir')
    if not os.path.exists(xml_tmp_dir):
        os.mkdir(xml_tmp_dir)
    apk_name = os.path.splitext(os.path.basename(apk_path))[0]
    try:
        apk_path = os.path.abspath(apk_path)
        a = APK(apk_path)
        f = open(os.path.join(xml_tmp_dir, apk_name + '.xml'), 'wb')
        xmlstreaming = etree.tostring(a.xml['AndroidManifest.xml'], pretty_print=True, encoding='utf-8')
        f.write(xmlstreaming)
        f.close()
    except Exception as e:
        print("Fail to load xml file of apk {}".format(apk_path))
        print(str(e))

        return requested_permission_list, activity_list, service_list, content_provider_list, broadcast_receiver_list, hardware_list, intentfilter_list

    # start obtain features S1, S2, S3, S4
    try:
        with open(os.path.join(xml_tmp_dir, apk_name + '.xml'), 'rb') as f:
            dom_xml = minidom.parse(f)
            dom_elements = dom_xml.documentElement

            dom_permissions = dom_elements.getElementsByTagName('uses-permission')
            for permission in dom_permissions:
                if permission.hasAttribute('android:name'):
                    requested_permission_list.append(permission.getAttribute('android:name'))

            dom_activities = dom_elements.getElementsByTagName('activity')
            for activity in dom_activities:
                if activity.hasAttribute('android:name'):
                    activity_list.append(activity.getAttribute('android:name'))

            dom_services = dom_elements.getElementsByTagName("service")
            for service in dom_services:
                if service.hasAttribute("android:name"):
                    service_list.append(service.getAttribute("android:name"))

            dom_contentproviders = dom_elements.getElementsByTagName("provider")
            for provider in dom_contentproviders:
                if provider.hasAttribute("android:name"):
                    content_provider_list.append(provider.getAttribute("android:name"))

            dom_broadcastreceivers = dom_elements.getElementsByTagName("receiver")
            for receiver in dom_broadcastreceivers:
                if receiver.hasAttribute("android:name"):
                    broadcast_receiver_list.append(receiver.getAttribute("android:name"))

            dom_hardwares = dom_elements.getElementsByTagName("uses-feature")
            for hardware in dom_hardwares:
                if hardware.hasAttribute("android:name"):
                    hardware_list.append(hardware.getAttribute("android:name"))

            dom_intentfilter_actions = dom_elements.getElementsByTagName("action")
            for action in dom_intentfilter_actions:
                if action.hasAttribute("android:name"):
                    intentfilter_list.append(action.getAttribute("android:name"))

            return requested_permission_list, activity_list, service_list, content_provider_list, broadcast_receiver_list, hardware_list, intentfilter_list
    except Exception as e:
        print("Fail to process xml file of apk {}".format(apk_path))
        print(str(e))
        return requested_permission_list, activity_list, service_list, content_provider_list, broadcast_receiver_list, hardware_list, intentfilter_list


def get_feature_dex(apk_path, pmap, requested_permission_list):
    """
    get requested features from .dex files
    :param apk_path: an absolute path of an apk
    :param pmap: PScout mapping
    :param requested_permission_list: a list of permissions
    :return: tupe of lists
    """
    used_permission_list = []
    restricted_api_list = []
    suspicious_api_list = []
    url_list = []

    try:
        apk_path = os.path.abspath(apk_path)
        a, dd, dx = AnalyzeAPK(apk_path)
    except Exception as e:
        print("Fail to load 'dex' files of apk " + apk_path)
        return

    if not isinstance(dd, list):
        dd = [dd]  # may accommodate multiple dex files
    try:
        for i, d in enumerate(dd):
            for mtd in d.get_methods():
                dex_content = dx.get_method(mtd)
                for basic_block in dex_content.get_basic_blocks().get():
                    dalvik_code_list = []
                    for instruction in basic_block.get_instructions():
                        # dalvik code + performed body (api + arguments + return type)
                        code_line = instruction.get_name() + ' ' + instruction.get_output()
                        dalvik_code_list.append(code_line)
                    apis, suspicious_apis = get_specific_api(dalvik_code_list)
                    used_permissions, restricted_apis = get_permission_and_apis(apis,
                                                                                pmap,
                                                                                requested_permission_list,
                                                                                suspicious_apis)
                    used_permission_list.extend(used_permissions)
                    restricted_api_list.extend(restricted_apis)
                    suspicious_api_list.extend(suspicious_apis)

                    for code_line in dalvik_code_list:
                        url_search = re.search(
                            r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+',
                            code_line,
                            re.IGNORECASE)
                        if url_search:
                            url = url_search.group()
                            url_domain = re.sub(r'(.*://)?([^/?]+).*', '\g<1>\g<2>', url)
                            url_list.append(url_domain)
        # remove duplication
        used_permission_list = list(set(used_permission_list))
        restricted_api_list = list(set(restricted_api_list))
        suspicious_api_list = list(set(suspicious_api_list))
        url_list = list(set(url_list))
        return used_permission_list, restricted_api_list, suspicious_api_list, url_list
    except Exception as e:
        print("Fail to process 'dex' files of apk " + apk_path)
        print(str(e))
        return used_permission_list, restricted_api_list, suspicious_api_list, url_list


def get_specific_api(dalvik_code_list):
    """
    get invoked apis
    :param dalvik_code_list: a list of dalvik codes (line by line)
    :return: list of apis and list of suspicious apis
    """
    api_list = []
    suspicious_api_list = []

    for code_line in dalvik_code_list:
        if 'invoke-' in code_line:
            sub_parts = code_line.split(',')
            for part in sub_parts:
                if ';->' in part:
                    part = part.strip()
                    if part.startswith('Landroid'):
                        entire_api = part
                        api_parts = part.split(';->')
                        api_class = api_parts[0].strip()
                        api_name = api_parts[1].split('(')[0].strip()
                        api_dict = {'entire_api': entire_api, 'api_class': api_class, 'api_name': api_name}
                        api_list.append(api_dict)
                        if api_name in SuspiciousNames:
                            suspicious_api_list.append(api_class + '.' + api_name)
                for e in suspicious_api_list:
                    if e in part:
                        suspicious_api_list.append(e)

        for e in suspicious_api_list:
            if e in code_line:
                suspicious_api_list.append(e)

    # remove duplication
    suspicious_api_list = list(set(suspicious_api_list))

    return api_list, suspicious_api_list


def get_permission_and_apis(apis, pmap, requested_permission_list, suspicious_apis):
    """
    used permission and apis
    :param apis: a list of apis
    :param pmap: pscout mapping
    :param requested_permission_list: a list of permission
    :param suspicious_apis: a list of apis
    :return: used permission, restricted apis
    """
    used_permission_list = []
    restricted_api_list = []
    for api in apis:
        api_class = api['api_class'].replace('/', '.').replace("Landroid", "android").strip()
        permission = pmap.GetPermFromApi(api_class, api['api_name'])
        if permission is not None:
            if (permission in requested_permission_list) and (len(requested_permission_list) > 0):
                used_permission_list.append(permission)
                api_info = api_class + '.' + api['api_name']
                if api_info not in suspicious_apis:
                    restricted_api_list.append(api_info)
            else:
                api_info = api_class + '.' + api['api_name']
                if api_info not in suspicious_apis:
                    restricted_api_list.append(api_info)
    # remove duplication
    used_permission_list = list(set(used_permission_list))
    restricted_api_list = list(set(restricted_api_list))

    return used_permission_list, restricted_api_list


def dump_feature(new_path, data_dict):
    if not os.path.exists(os.path.dirname(new_path)):
        utils.mkdir(os.path.dirname(new_path))

    if not isinstance(data_dict, dict):
        raise TypeError("Not 'dict' format")

    with open(new_path, 'w') as f:
        for k, v in data_dict.items():
            for _v in v:
                f.write(str(k) + '_' + str(_v) + '\n')


class AxplorerMapping(object):
    def __init__(self):
        with open(os.path.join(current_dir, 'res/axplorerPermApi22Mapping.json'), 'rb') as FH:
            # Use SmallCase json file to prevent run time case conversion in GetPermFromApi
            import json
            self.PermApiDictFromJsonTemp = json.load(FH)
            self.PermApiDictFromJson = {}
            for Perms in self.PermApiDictFromJsonTemp:
                for Api in range(len(self.PermApiDictFromJsonTemp[Perms])):
                    ApiName = self.PermApiDictFromJsonTemp[Perms][Api][0].lower() + \
                              self.PermApiDictFromJsonTemp[Perms][Api][1].lower()
                    '''Exchange key and values inside the dictionary.'''
                    self.PermApiDictFromJson[ApiName] = Perms
        del self.PermApiDictFromJsonTemp

    def GetAllPerms(self):
        return list(self.PermApiDictFromJson.keys())

    def GetAllApis(self):
        return list(self.PermApiDictFromJson.values())

    def GetApisFromPerm(self, Perm):
        PermAsKey = Perm
        if PermAsKey not in self.PermApiDictFromJson:
            logger.error("Permission %s not found in the PScout Dict",
                         PermAsKey)
            return -1
        else:
            return self.PermApiDictFromJson[PermAsKey]

    def GetPermFromApi(self, ApiClass, ApiMethodName):
        ApiClass = ApiClass.lower()
        ApiMethodName = ApiMethodName.lower()

        ApiName = ApiClass + ApiMethodName
        if (ApiClass + ApiMethodName) in self.PermApiDictFromJson:
            return self.PermApiDictFromJson[ApiName]
        else:
            return None

    def PrintDict(self):
        pprint(self.PermApiDictFromJson)

    def PrintAllPerms(self):
        for PermAsKey in self.PermApiDictFromJson:
            print(PermAsKey)

    def PrintAllApis(self):
        for Api in self.PermApiDictFromJson.values():
            print(Api)

    def PrintApisForPerm(self, Perm):
        PermAsKey = Perm

        if PermAsKey not in self.PermApiDictFromJson:
            warnings.warn("Permission {} not found in the PScout Dict".format(
                PermAsKey))
            return -1

        for Api in self.PermApiDictFromJson[Perm]:
            pprint(Api)
        return 0

    ##################################################
    #                 Sorting the dict               #
    ##################################################
    def SortDictByKeys(self):
        self.PermApiDictFromJson = \
            collections.OrderedDict(sorted(self.PermApiDictFromJson.items()))
