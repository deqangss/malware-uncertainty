"""
- String feature
- Permission feature
- Component feature
- Environmental feature
- Method opcode feature
- Method API feature
- Shared library function opcode feature
"""

import os
import sys
import time
import warnings
import multiprocessing

import magic
import zipfile
import hashlib
from collections import defaultdict, Counter

import numpy as np

from androguard.misc import AnalyzeAPK, APK
import lxml.etree as etree
from xml.dom import minidom


from elftools.elf.elffile import ELFFile
from elftools.common.py3compat import BytesIO
from capstone import Cs, CS_ARCH_ARM64, CS_ARCH_ARM, CS_MODE_ARM

current_dir = os.path.dirname(os.path.realpath(__file__))

from sys import platform as _platform
from tools import progressbar_wrapper, utils

if _platform == "linux" or _platform == "linux2":
    TMP_DIR = '/tmp/'
elif _platform == "win32" or _platform == "win64":
    TMP_DIR = 'C:\\TEMP\\'


def get_vocab(feature_list, use_feature_selection=False, gt_labels=None, dim=10000):
    """
    build vocabulary for five kinds of features, including permission/component/environment, string, method api,
    method opcodes, shared library, each of which are presented in the 'collections.defaultdict' format
    :param feature_list: 2D shape, each row denotes features extracted from an apk
    :param use_feature_selection: conducting feature extraction or not (False means no, and True means yes)
    :param gt_labels: ground truth labels (optional)
    :param dim: the number of selected features (optional)
    :return: list of vocabularies corresponding to five kinds of features, list of numerical feature representations,
    ground truth labels
    """
    assert isinstance(feature_list, list) and len(feature_list) > 0

    feature_np = np.array(feature_list, dtype=defaultdict, ndmin=2)
    if len(feature_np.shape) != 2:
        warnings.warn("Feature extraction may be failed for some instances!")

    number_of_types = feature_np.shape[1]
    vocabulary_list = []
    dataX_list = []
    for t in range(number_of_types):
        feature_dicts = feature_np[:, t]  # a column of a type of features (dict container)
        c = Counter()
        for fd in feature_dicts:
            for k, v in fd.items():
                c[k] += v
        if not use_feature_selection:
            if len(c) > 0:
                vocab, count = zip(*c.items())
            else:
                vocab = []
        else:
            if len(c) > 0:
                vocab, count = zip(*c.most_common(dim))  # filter out words with low frequency
            else:
                vocab = []

        vocabulary_list.append(list(vocab))
        # get representation
        representations = get_feature_representation(feature_dicts, vocab)
        # N = len(feature_dicts)
        # M = len(list(vocab))
        # representations = np.zeros((N, M), dtype=np.float32)
        # dictionary = dict(zip(vocab, range(M)))
        # for i, fd in enumerate(feature_dicts):
        #     if len(fd) > 0:
        #         filled_positions = [idx for idx in list(map(dictionary.get, list(fd.keys()))) if idx is not None]
        #         filled_values = [fd.get(key) for key in list(fd.keys()) if dictionary.get(key) is not None]
        #         if len(filled_positions) != 0:
        #             representations[i, filled_positions] = filled_values[:]
        #         else:
        #             warnings.warn("Produce zero feature vector.")

        dataX_list.append(representations)
    return vocabulary_list, dataX_list, gt_labels


def get_feature_representation(feature_dict_list, vocab):
    """
    mapping feature to numerical representation
    :param feature_dict_list: feature list with shape [number of files, a dictionary of features]
    :param vocab: a list of words
    :return: 2D representation
    :rtype numpy.ndarray
    """
    N = len(feature_dict_list)
    M = len(list(vocab))
    representations = np.zeros((N, M), dtype=np.float32)
    dictionary = dict(zip(vocab, range(M)))
    for i, fd in enumerate(feature_dict_list):
        if len(fd) > 0:
            filled_positions = [idx for idx in list(map(dictionary.get, list(fd.keys()))) if idx is not None]
            filled_values = [fd.get(key) for key in list(fd.keys()) if dictionary.get(key) is not None]
            if len(filled_positions) != 0:
                representations[i, filled_positions] = filled_values[:]
            else:
                warnings.warn("Produce zero feature vector.")

    return representations


def feature_extraction(sample_dir, backup_path=None, proc_number=2):
    """
    extract multiple kinds of features
    :param sample_dir: a folder of sample paths
    :param backup_path: save intermediate features
    :param proc_number: the number of processing threads
    :return: list of features, [[{feature_name:value, feature_name:value,...},
    {feature_name:value,...},...]...]
    """
    if (not isinstance(sample_dir, str)) and (not isinstance(sample_dir, list)):
        MSG = "A directory or a list of path is allowed!"
        raise ValueError(MSG)

    if isinstance(sample_dir, str):
        if not os.path.exists(sample_dir):
            MSG = "No such directory or file {} exists!".format(sample_dir)
            raise ValueError(MSG)
        elif os.path.isfile(sample_dir):
            sample_path_list = [sample_dir]
        elif os.path.isdir(sample_dir):
            sample_path_list = list(utils.retrive_files_set(sample_dir, "", ".apk|"))
            assert len(sample_path_list) > 0, 'No files'
        else:
            raise ValueError(" No such path {}".format(sample_dir))

    if isinstance(sample_dir, list):
        sample_path_list = sample_dir

    if backup_path is None:
        backup_path = os.path.join(TMP_DIR, 'backup_multimodal')
    utils.mkdir(backup_path)

    pool = multiprocessing.Pool(int(proc_number))
    pbar = progressbar_wrapper.ProgressBar()
    process_results = []
    tasks = []
    result_paths = []
    api_list = utils.read_txt(os.path.join(current_dir, 'res/api_list.txt'), mode = 'r')
    api_list = [s.decode('utf-8') for s in api_list]

    for i, apk_path in enumerate(sample_path_list):
        sample_name = os.path.splitext(os.path.basename(apk_path))[0]
        back_path_name = os.path.join(backup_path, sample_name + '.data')
        if os.path.exists(back_path_name):
            result_paths.append(back_path_name)
            continue
        tasks.append(apk_path)
        process_results = pool.apply_async(get_multimod_feature,
                                           args=(apk_path, api_list, back_path_name),
                                           callback=pbar.CallbackForProgressBar)

    pool.close()
    if process_results:
        pbar.DisplayProgressBar(process_results, len(tasks), type='hour')
    pool.join()

    for i, res in enumerate(pbar.TotalResults):
        status, res_path = res
        if status:
            result_paths.append(res_path)

    feature_list = []
    for res_path in result_paths:
        features = utils.load_json(res_path)
        feature_list.append(features)

    return feature_list


def get_multimod_feature(apk_path, api_list, save_path):
    """
    get features
    :param apk_path: an absolute apk path
    :param api_list: api list, api level 22 is considered
    :param save_path: a path for saving features
    :return: (status, result_file_path), e.g., (True, back_path_name+apk_name+'.data')
    """
    try:
        print("Processing " + apk_path)
        start_time = time.time()
        data_list = []
        # permission, components, environment information
        data_list.append(get_dict_feature_xml(apk_path))
        # string, method api, method opcodes
        string_feature_dict, api_feature_dict, opcode_feature_dict = get_feature_dex(apk_path, api_list)
        data_list.extend([string_feature_dict, api_feature_dict, opcode_feature_dict])
        # shared library feature
        data_list.append(get_feature_shared_lib(apk_path))

        utils.dump_json(data_list, save_path)
    except Exception as e:
        end_time = time.time()
        print("Fail to process " + apk_path + " during the time " + str(end_time - start_time))
        print(str(e))
        return False, save_path
    else:
        end_time = time.time()
        print("Success to process " + apk_path + " during the time " + str(end_time - start_time))
        return True, save_path


def get_dict_feature_xml(apk_path):
    """
    get requested features from manifest file
    :param apk_path: absolute path of an apk file
    :return: a dict of elements {feature:occurrence, ..., }
    """
    permission_component_envinfo = defaultdict(int)
    xml_tmp_dir = os.path.join(TMP_DIR, 'xml_dir')
    if not os.path.exists(xml_tmp_dir):
        os.mkdir(xml_tmp_dir)
    apk_name = os.path.splitext(os.path.basename(apk_path))[0]
    try:
        apk_path = os.path.abspath(apk_path)
        a = APK(apk_path)
        f = open(os.path.join(xml_tmp_dir, apk_name + '.xml'), 'wb')
        xmlstreaming = etree.tostring(a.xml['AndroidManifest.xml'], pretty_print=True, encoding='utf-8')
        f.write(xmlstreaming)
        f.close()
    except Exception as e:
        print("Fail to load xml file of apk {}".format(apk_path))
        print(str(e))

        return permission_component_envinfo

    # start obtain feature permission, components, environment information
    try:
        with open(os.path.join(xml_tmp_dir, apk_name + '.xml'), 'rb') as f:
            dom_xml = minidom.parse(f)
            dom_elements = dom_xml.documentElement

            dom_permissions = dom_elements.getElementsByTagName('uses-permission')
            for permission in dom_permissions:
                if permission.hasAttribute('android:name'):
                    permission_component_envinfo[permission.getAttribute('android:name')] = 1

            dom_activities = dom_elements.getElementsByTagName('activity')
            for activity in dom_activities:
                if activity.hasAttribute('android:name'):
                    permission_component_envinfo[activity.getAttribute('android:name')] = 1

            dom_services = dom_elements.getElementsByTagName("service")
            for service in dom_services:
                if service.hasAttribute("android:name"):
                    permission_component_envinfo[service.getAttribute("android:name")] = 1

            dom_contentproviders = dom_elements.getElementsByTagName("provider")
            for provider in dom_contentproviders:
                if provider.hasAttribute("android:name"):
                    permission_component_envinfo[provider.getAttribute("android:name")] = 1
                # uri
                dom_uris = provider.getElementsByTagName('grant-uri-permission')
                # intents --- action
                intent_actions = provider.getElementsByTagName('action')
                # we neglect to compose the uri feature by so-called paired provider name and intents
                # instead, the path of uri is used directly
                for uri in dom_uris:
                    if uri.hasAttribute('android:path'):
                        permission_component_envinfo[uri.getAttribute('android:path')] = 1

            dom_broadcastreceivers = dom_elements.getElementsByTagName("receiver")
            for receiver in dom_broadcastreceivers:
                if receiver.hasAttribute("android:name"):
                    permission_component_envinfo[receiver.getAttribute("android:name")] = 1

            dom_intentfilter_actions = dom_elements.getElementsByTagName("action")
            for action in dom_intentfilter_actions:
                if action.hasAttribute("android:name"):
                    permission_component_envinfo[action.getAttribute("android:name")] = 1

            dom_hardwares = dom_elements.getElementsByTagName("uses-feature")
            for hardware in dom_hardwares:
                if hardware.hasAttribute("android:name"):
                    permission_component_envinfo[hardware.getAttribute("android:name")] = 1

            dom_libraries = dom_elements.getElementsByTagName("android:name")
            for lib in dom_libraries:
                if lib.hasAttribute('android:name'):
                    permission_component_envinfo[lib.getAttribute('android:name')] = 1

            dom_sdk_versions = dom_elements.getElementsByTagName("uses-sdk")
            for sdk in dom_sdk_versions:
                if sdk.hasAttribute('android:minSdkVersion'):
                    permission_component_envinfo[sdk.getAttribute('android:minSdkVersion')] = 1
                if sdk.hasAttribute('android:targetSdkVersion'):
                    permission_component_envinfo[sdk.getAttribute('android:targetSdkVersion')] = 1
                if sdk.hasAttribute('android:maxSdkVersion'):
                    permission_component_envinfo[sdk.getAttribute('android:maxSdkVersion')] = 1

            return permission_component_envinfo
    except Exception as e:
        print("Fail to process xml file of apk {}".format(apk_path))
        print(str(e))

        return permission_component_envinfo


def get_feature_dex(apk_path, api_list):
    """
    get features about opcode and functions, and string from .dex files
    :param apk_path: an absolute path of an apk
    :param api_list: a list of apis
    :return:  two dicts of elements {feature:occurrence, ..., } corresponds to functionality features and string feature
    """
    string_feature_dict = defaultdict(int)
    opcode_feature_dict = defaultdict(int)
    api_feature_dict = defaultdict(int)

    try:
        _1, _2, dx = AnalyzeAPK(apk_path)
    except Exception as e:
        print('Fail to load dex file of apk {}'.format(apk_path))
        print(str(e))
        return string_feature_dict, api_feature_dict, opcode_feature_dict

    for method in dx.get_methods():
        if method.is_external():
            continue
        method_obj = method.get_method()
        for instruction in method_obj.get_instructions():
            opcode = instruction.get_name()
            opcode_feature_dict[opcode] += 1
            if 'invoke-' in opcode:
                code_body = instruction.get_output()
                if ';->' not in code_body:
                    continue
                head_part, rear_part = code_body.split(';->')
                class_name = head_part.strip().split(' ')[-1]
                method_name = rear_part.strip().split('(')[0]
                if class_name + ';->' + method_name in api_list:
                    api_feature_dict[class_name + ';->' + method_name] += 1

            if (opcode == 'const-string') or (opcode == 'const-string/jumbo'):
                code_body = instruction.get_output()
                ss_string = code_body.split(' ')[-1].strip('\'').strip('\"').encode('utf-8')
                if not ss_string:
                    continue
                hashing_string = hashlib.sha512(ss_string).hexdigest()
                string_feature_dict[hashing_string] = 1

    return string_feature_dict, api_feature_dict, opcode_feature_dict


def get_feature_shared_lib(apk_path):
    """
    get features from ELF files
    :param apk_path: an absolute path of an apk
    :return: a dict of elements {feature:occurrence, ..., }
    """
    feature_dict = defaultdict(int)
    try:
        with zipfile.ZipFile(apk_path, 'r') as apk_zipf:
            handled_name_list = []
            for name in apk_zipf.namelist():
                if os.path.basename(name) in handled_name_list:
                    continue
                brief_file_info = magic.from_buffer(apk_zipf.read(name))
                if 'ELF' not in brief_file_info:
                    continue
                if 'ELF 64' in brief_file_info:
                    arch_info = CS_ARCH_ARM64
                elif 'ELF 32' in brief_file_info:
                    arch_info = CS_ARCH_ARM
                else:
                    raise ValueError("Android ABIs with Arm 64-bit or Arm 32 bit are support.")

                with apk_zipf.open(name, 'r') as fr:
                    bt_stream = BytesIO(fr.read())
                    elf_fhander = ELFFile(bt_stream)
                    # arm opcodes (i.e., instructions)
                    bt_code_text = elf_fhander.get_section_by_name('.text')
                    if bt_code_text.data() is not None:
                        md = Cs(arch_info, CS_MODE_ARM)
                        for _1, _2, op_code, _3 in md.disasm_lite(bt_code_text.data(), 0x1000):
                            feature_dict[op_code] += 1
                    # functions
                    # we consider about whether a function occurs or not, not its frequency, for easing implementation.
                    # if only running the codes on linux platform, we suggest the tool of 'objdump', which can be used
                    # to count the frequency of functions conveniently. We here utilize 'pyelftools' to accommodate
                    # different development environments.
                    REL_PLT_section = elf_fhander.get_section_by_name('.rela.plt')
                    if REL_PLT_section is None:
                        continue
                    symtable = elf_fhander.get_section(REL_PLT_section['sh_link'])

                    for rel_plt in REL_PLT_section.iter_relocations():
                        func_name = symtable.get_symbol(rel_plt['r_info_sym']).name
                        feature_dict[func_name] += 1

                handled_name_list.append(os.path.basename(name))
        return feature_dict
    except Exception as e:
        print("Fail to process shared library file of apk {}".format(apk_path))
        print(str(e))
        return feature_dict


def _main():
    import pprint
    # path = 'F:\\dataSet\\android\\testapks\\clash-of-lights.apk'
    path = 'F:\\dataSet\\android\\testapks\\a7656e0b8868c939652b318a576314d259d43bfee2e4660588968946c23a9b7'
    # pprint.pprint(get_feature_shared_lib(path))
    feature_extraction(path)


if __name__ == '__main__':
    sys.exit(_main())
