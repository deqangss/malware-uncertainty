import os
import sys
import time
import warnings
import multiprocessing

from collections import defaultdict, Counter
from androguard.misc import AnalyzeAPK
from tools import utils, progressbar_wrapper

current_dir = os.path.dirname(os.path.realpath(__file__))
from sys import platform as _platform

if _platform == "linux" or _platform == "linux2":
    TMP_DIR = '/tmp/drod_xml_files/'
elif _platform == "win32" or _platform == "win64":
    TMP_DIR = 'C:\\TEMP\\'

REM_CLASS_HEAD_LIST = [
    'Ljava/', 'Ljavax/'
]


def get_vocab(feature_list, gt_labels, use_feature_selection=True):
    """
    create vocabulary based on a list of features
    :param feature_list: 2D list with inconsistent column number, each row denotes features extracted from an apk,
    :param gt_labels: ground truth labels
    :param use_feature_selection: using feature selection or not
    :return: vocabulary
    :rtype: list
    """
    c_mal = Counter()
    c_ben = Counter()

    for features, label in zip(feature_list, gt_labels):
        if label:
            c_mal.update(features)
        else:
            c_ben.update(features)

    if not use_feature_selection:
        c_mal.update(c_ben)
        c_all = c_mal
    else:
        api_num_mal = len(c_mal)
        api_hf_mal = c_mal.most_common(int(api_num_mal * (1. - 0.75)))
        api_num_ben = len(c_ben)
        api_hf_ben = c_ben.most_common(int(api_num_ben * (1. - 0.75)))
        common_apis = [e for e in api_hf_mal if e in api_hf_ben]
        for api in common_apis:
            c_mal[api] = 0
            c_ben[api] = 0
        c_mal.update(c_ben)
        c_all = c_mal

    vocab, count = zip(*c_all.items())
    return list(vocab)


def get_discrete_representation(feature_list, gt_labels, dictionary):
    """
    obtain the numerical sequence for the given dictionary
    :param feature_list: 2D list with inconsistent column number, each row denotes features extracted from an apk
    :param gt_labels: ground truth labels
    :param dictionary: keys: vocabulary, corresponding value: index of vocabulary
    :return: 2D numerical feature, ground truth labels
    """
    numerical_features = []
    for i, features in enumerate(feature_list):
        if len(features) > 0:
            numerical_features = [idx for idx in list(map(dictionary.get, features)) if idx is not None]
            if len(numerical_features) == 0:
                warnings.warn("Produce zero feature vector.")
            numerical_features.append(numerical_features)
    return numerical_features, gt_labels


def _check_class(class_name):
    flag = True
    for cls_head in REM_CLASS_HEAD_LIST:
        if class_name.startswith(cls_head):
            flag = False
            break
    return flag


def _dfs(api, nodes, seq=[], visited=[]):
    if api not in nodes.keys():
        seq.append(api)
    else:
        visited.append(api)
        for elem in nodes[api]:
            if elem in visited:
                seq.append(elem)
            else:
                _dfs(elem, nodes, seq, visited)


def get_api_sequence(apk_path, save_path):
    """
    produce an api call sequence for an apk
    :param apk_path: an apk path
    :param save_path: path for saving resulting features
    :return: (status, back_path_name)
    """
    try:
        start_time = time.time()
        # obtain tow dictionaries: xref_from and xref_to, of which key is class-method name
        # and value is the caller or callee.
        _, _, dx = AnalyzeAPK(apk_path)
        mth_callers = defaultdict(list)
        mth_callees = defaultdict(list)
        for cls_obj in dx.get_classes():  # ClassAnalysis
            if cls_obj.is_external():
                continue
            cls_name = cls_obj.name
            for mth_obj in cls_obj.get_methods():
                if mth_obj.is_external():
                    continue

                m = mth_obj.get_method()  # dvm.EncodedMethod
                cls_mth_name = cls_name + '->' + m.name + m.proto
                # get callers
                mth_callers[cls_mth_name] = []
                for _, call, _ in mth_obj.get_xref_from():
                    if _check_class(call.class_name):
                        mth_callers[cls_mth_name].append(call.class_name + '->' + call.name + call.proto)
                # get callees sequentially
                for instruction in m.get_instructions():
                    opcode = instruction.get_name()
                    if 'invoke-' in opcode:
                        code_body = instruction.get_output()
                        if '->' not in code_body:
                            continue
                        head_part, rear_part = code_body.split('->')
                        class_name = head_part.strip().split(' ')[-1]
                        mth_name_callee = class_name + '->' + rear_part
                        if _check_class(mth_name_callee):
                            mth_callees[cls_mth_name].append(mth_name_callee)

        # look for the root call
        root_calls = []
        num_of_calls = len(mth_callers.items())
        if num_of_calls == 0:
            return False, save_path
        for k in mth_callers.keys():
            if (len(mth_callers[k]) <= 0) and (len(mth_callees[k]) > 0):
                root_calls.append(k)

        if len(root_calls) == 0:
            warnings.warn("Cannot find a root call, instead, randomly pick up one.")
            import random
            id = random.choice(range(num_of_calls))
            root_calls.append(mth_callers.keys()[id])

        # generate sequence
        api_sequence = []
        for root_call in root_calls:
            sub_seq = []
            visited_nodes = []
            _dfs(root_call, mth_callees, sub_seq, visited_nodes)
            api_sequence.extend(sub_seq)
        # dump features
        utils.dump_txt('\n'.join(api_sequence), save_path)
    except Exception as e:
        end_time = time.time()
        print("Fail to process " + apk_path + " during the time " + str(end_time - start_time))
        print(str(e))
        import traceback
        traceback.print_exc()
        return False, save_path
    else:
        end_time = time.time()
        print("Success to process " + apk_path + " during the time " + str(end_time - start_time))
        return True, save_path


def feature_extraction(sample_dir, backup_path=None, proc_number=2):
    """
    extract api sequences
    :param sample_dir: a folder contains apk files
    :param backup_path: saving intermediate data
    :param proc_number: the number of processing threads
    :return: list of nested features, [[api sequence], [api sequence], ... ...]
    """
    if not isinstance(sample_dir, str) and not isinstance(sample_dir, list):
        MSG = "A directory or a list of path is allowed!"
        raise ValueError(MSG)

    if isinstance(sample_dir, str):
        if not os.path.exists(sample_dir):
            MSG = "No such directory or file {} exists!".format(sample_dir)
            raise ValueError(MSG)
        elif os.path.isfile(sample_dir):
            sample_path_list = [sample_dir]
        elif os.path.isdir(sample_dir):
            sample_path_list = list(utils.retrive_files_set(sample_dir, "", ".apk|"))
            assert len(sample_path_list) > 0, 'No files'
        else:
            raise ValueError(" No such path {}".format(sample_dir))

    if backup_path is None:
        backup_path = os.path.join(TMP_DIR, 'api_sequence')
    utils.mkdir(backup_path)

    pool = multiprocessing.Pool(int(proc_number))
    pbar = progressbar_wrapper.ProgressBar()
    process_results = []
    tasks = []
    result_paths = []

    for i, apk_path in enumerate(sample_path_list):
        sample_name = os.path.splitext(os.path.basename(apk_path))[0]
        back_path_name = os.path.join(backup_path, sample_name + '.data')
        if os.path.exists(back_path_name):
            result_paths.append(back_path_name)
            continue
        tasks.append(apk_path)
        process_results = pool.apply_async(get_api_sequence,
                                           args=(apk_path, back_path_name),
                                           callback=pbar.CallbackForProgressBar)

    pool.close()
    if process_results:
        pbar.DisplayProgressBar(process_results, len(tasks), type='hour')
    pool.join()

    for i, res in enumerate(pbar.TotalResults):
        status, res_path = res
        if status:
            result_paths.append(res_path)

    feature_list = []
    for res_path in result_paths:
        features = utils.read_txt(res_path)
        feature_list.append(features)

    return feature_list


def _main():
    import pprint
    # path = 'F:\\dataSet\\android\\testapks\\clash-of-lights.apk'
    path = 'F:\\dataSet\\android\\testapks\\TestActivity.apk'
    # pprint.pprint(get_feature_shared_lib(path))
    feature_extraction(path)


if __name__ == '__main__':
    sys.exit(_main())
