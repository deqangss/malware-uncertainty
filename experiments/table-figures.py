from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import itertools

import os
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
from scipy import interpolate
from sklearn.metrics import f1_score, accuracy_score, confusion_matrix, balanced_accuracy_score, roc_auc_score, \
    roc_curve
from sklearn.calibration import calibration_curve

from tools import utils
from tools.metrics import nll, brier_score, expected_calibration_error, entropy, predictive_kld, predictive_std
from tools.metrics import b_nll, b_brier_score
from config import config, logging, ErrorHandler

logger = logging.getLogger('table-figures')
logger.addHandler(ErrorHandler)

detection_methods_dict = {
    'drebin': 'DeepDrebin',
    'multimodality': 'MultimodalNN',
    'opcodeseq': 'DeepDroid'
}
calibration_methods_dict = {
    'vanilla': 'Vanilla',
    'temperature': 'Temp scaling',
    'mc_dropout': 'MC dropout',
    'bayesian': 'VBI',
    'deep_ensemble': 'Ensemble',
    'weighted_ensemble': 'wEnsemble'
}

fig_path = '../result-figs/'
if not os.path.exists(fig_path):
    os.makedirs(fig_path)

binwidth = 0.01


def get_result_path(dataset_name='drebin', detection_method='drebin', calibration_method='vanilla', exp_mode='test'):
    if dataset_name == 'drebin':
        save_dir = config.get('experiments', 'drebin')
    elif dataset_name == 'androzoo_tesseract':
        save_dir = config.get('experiments', 'androzoo')
    elif dataset_name == 'oos':
        save_dir = config.get('experiments', 'oos')
    elif dataset_name == 'adv':
        save_dir = config.get('experiments', 'adv')
    else:
        raise ValueError("Expect 'drebin', 'androzoo_tesseract', 'oos', and 'adv'.")

    if exp_mode == 'test':
        suffix_string = 'test.res'
    elif exp_mode == 'oos':
        suffix_string = 'drebin_oos.res'
    elif exp_mode == 'adv':
        suffix_string = 'drebin_adv.res'
    else:
        raise ValueError("Except 'test', 'oos', and 'adv' modes.")

    if calibration_method == 'temperature':
        suffix_string = 'temperature_' + suffix_string
        calibration_method = 'vanilla'

    return os.path.join(save_dir, '{}_{}_{}'.format(detection_method, calibration_method, suffix_string))


def get_prob_drebin(path, calibration_method):
    res_pkl = utils.read_joblib(path)
    if calibration_method == 'weighted_ensemble':
        (x_prob, weights), gt_labels = res_pkl
        x_prob = np.squeeze(np.matmul(np.squeeze(x_prob, axis=-1), weights[0]), axis=-1)
    elif calibration_method == 'temperature':
        x_prob, gt_labels = res_pkl
        x_prob = np.squeeze(x_prob, axis=-1)
    else:
        x_prob, gt_labels = res_pkl
        x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)
    return x_prob, gt_labels


def roc_curve_plot(y_true, y_score, pos_label=1,
                   legend_prefix='', recommendation=False, n_bootstrap=10000,
                   color=None):
    """Compute and plot receiver operating characteristic (ROC)

    Parameters
    ==========

    y_true : array, shape = [n_samples]
        True binary labels in range {0, 1} or {-1, 1}.  If labels are not
        binary, pos_label should be explicitly given.

    y_score : array, shape = [n_samples]
        Target scores, can either be probability estimates of the positive
        class or confidence values.

    pos_label : int
        Label considered as positive and others are considered negative.

    legend_prefix : string, by default empty
        plot legend: 'legend_prefix (auc=XX)'

    recommendation : boolean, False by default
        plot recommendations of British Diabetic Association and NHS

    """
    assert y_score.ndim == 1, 'y_score should be of shape (n_samples,)'
    assert len(y_true) == len(y_score), \
        'y_true and y_score must both be n_samples long'

    low, high = bootstrap([y_true, y_score], roc_auc_score,
                          n_resamples=n_bootstrap, alpha=0.05)

    fdr_low, tdr_low, _ = roc_curve(y_true[low.index],
                                    y_score[low.index],
                                    pos_label=pos_label)
    fdr_high, tdr_high, _ = roc_curve(y_true[high.index],
                                      y_score[high.index],
                                      pos_label=pos_label)
    interpolate_low = interpolate.interp1d(fdr_low, tdr_low, kind='nearest')
    interpolate_high = interpolate.interp1d(fdr_high, tdr_high, kind='nearest')

    fdr, tdr, _ = roc_curve(y_true, y_score,
                            pos_label=pos_label)
    roc_auc = roc_auc_score(y_true, y_score)

    legend = legend_prefix  # + ' (auc:%0.3f; CI:%0.3f-%0.3f)' \
    # % (roc_auc, low.value, high.value)
    print(legend)

    plt.plot(fdr, tdr, color=color,
             label=legend, linewidth=2)
    plt.fill_between(fdr, interpolate_high(fdr), tdr, color=color, alpha=0.3)
    plt.fill_between(fdr, tdr, interpolate_low(fdr), color=color, alpha=0.3)
    plt.plot([0, 1], [0, 1], 'k--')
    if recommendation:
        plt.scatter([0.05], [0.8], color='g', s=50,
                    label='recommendation BDA')
        plt.scatter([0.2], [0.85], color='b', s=50,
                    label='recommendation NHS')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])
    plt.xlabel('1 - specificity')
    plt.ylabel('sensitivity')
    plt.legend(loc="lower right")


def table1():
    for det_mth, cal_mth in itertools.product(detection_methods_dict.keys(), calibration_methods_dict.keys()):
        path = get_result_path('drebin', det_mth, cal_mth)
        if not os.path.exists(path):
            logger.warning("No results of combining {} and {}: {}.".format(det_mth, cal_mth, path))
            continue
        res_pkl = utils.read_joblib(path)
        if cal_mth == 'weighted_ensemble':
            (x_prob, weights), gt_labels = res_pkl
            x_prob = np.squeeze(np.matmul(np.squeeze(x_prob, axis=-1), weights[0]), axis=-1)
        elif cal_mth == 'temperature':
            x_prob, gt_labels = res_pkl
            x_prob = np.squeeze(x_prob, axis=-1)
        else:
            x_prob, gt_labels = res_pkl
            x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)
        logger.info('Results in absence of concept drift from the model by combing {} and {}:'.format(det_mth, cal_mth))
        msg = ''
        y_pred = (x_prob >= 0.5).astype(np.int32)
        accuracy = accuracy_score(gt_labels, y_pred)
        baccuracy = balanced_accuracy_score(gt_labels, y_pred)
        msg += f'Accuracy: {accuracy * 100:.2f}, balanced accuracy: {baccuracy * 100:.2f} '
        tn, fp, fn, tp = confusion_matrix(gt_labels, y_pred).ravel()
        fpr = fp / float(tn + fp)
        fnr = fn / float(tp + fn)
        f1 = f1_score(gt_labels, y_pred, average='binary')
        msg += f'fpr: {fpr * 100:.2f}, fnr: {fnr * 100:.2f}, f1: {f1 * 100:.2f} | '
        _nll = nll(x_prob, gt_labels)
        _bnll = b_nll(x_prob, gt_labels)
        msg += f'NLL: {_nll:.3f}, bNLL: {_bnll:.3f} '
        _brier = brier_score(x_prob, gt_labels)
        _bbrier = b_brier_score(x_prob, gt_labels)
        msg += f'Brier score: {_brier:.3f}, bBrier score: {_bbrier:.3f} '
        _ece = expected_calibration_error(x_prob, gt_labels, bins=5)
        _uece = expected_calibration_error(x_prob, gt_labels, bins=5, use_unweighted_version=True)
        msg += f'ECE: {_ece:.3f}, uECE: {_uece:.3f}.'
        logger.info(msg)
    return


def fig2a():
    line_styles = ['-.', '-', '--', ':', '-.', '-']
    line_makers = ['v', '^', 'o', 's', 'h', '*']
    colors = sns.color_palette('deep')
    plt.figure(1, figsize=(6, 4))
    fs = 25
    plt.plot([0, 1], [0, 1], "k:", label="Well-calibrated", linewidth=4)
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        path = get_result_path('drebin', det_mth, 'vanilla')
        if not os.path.exists(path):
            logger.warning("No results of combining {} and {}: {}.".format(det_mth, cal_mth, path))
            continue
        res_pkl = utils.read_joblib(path)
        x_prob, gt_labels = res_pkl
        x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)
        prob_true, prob_pred = calibration_curve(gt_labels, x_prob, n_bins=5)
        plt.plot(prob_pred, prob_true, linestyle=line_styles[i], marker=line_makers[i], markersize=8, linewidth=4,
                 color=colors[i])
    plt.yticks(fontsize=fs)
    plt.xticks(fontsize=fs)
    axes = plt.gca()
    axes.set_ylabel('Ratio of positives', fontsize=fs)
    axes.set_xlim(0, 1)
    axes.set_ylim(0, 1)
    axes.set_xlabel('Mean of predicted value', fontsize=fs)
    axes.legend(loc=(0.02, 0.83), fontsize=fs, fancybox=True, framealpha=0.3)

    plt.subplots_adjust(bottom=0.01, top=0.95, left=0.1, right=0.9)
    plt.grid(linestyle='--')
    fig_eps = plt.gcf()
    fig_eps.savefig(os.path.join(fig_path, 'reliable_diag.pdf'), format='pdf', dpi=800, bbox_inches='tight')
    # plt.show()


def fig2b():
    line_styles = ['-.', '-', '--', ':', '-.', '-']
    line_makers = ['v', '^', 'o', 's', 'h', '*']
    colors = sns.color_palette('deep')
    num_of_mal_examples = []
    num_of_ben_examples = []
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        path = get_result_path('drebin', det_mth, 'vanilla')
        if not os.path.exists(path):
            logger.warning("No results of combining {} and {}: {}.".format(det_mth, cal_mth, path))
            continue
        res_pkl = utils.read_joblib(path)
        x_prob, gt_labels = res_pkl
        mal = gt_labels == 1
        x_prob_mal = x_prob[mal]
        probabilities = np.where(x_prob_mal == 0, 1e-8, x_prob_mal)
        counts, _ = np.histogram(probabilities, bins=5, range=[0., 1.])
        num_of_mal_examples.append(counts)
        x_prob_ben = x_prob[~mal]
        probabilities = np.where(x_prob_ben == 0, 1e-8, x_prob_ben)
        counts, _ = np.histogram(probabilities, bins=5, range=[0., 1.])
        num_of_ben_examples.append(counts)
    num_of_mal_examples = np.array(num_of_mal_examples)
    num_of_ben_examples = np.array(num_of_ben_examples)

    plt.figure(2, figsize=(10, 6))
    fs = 40
    x = [1, 2, 3, 4, 5]
    labels = [r'$B_1$', r'$B_2$', r'$B_3$', r'$B_4$', r'$B_5$']
    plt.subplot(121)
    for i in range(len(detection_methods_dict.keys())):
        plt.plot(x, num_of_ben_examples[i], linestyle=line_styles[i], marker=line_makers[i], markersize=12, linewidth=6,
                 color=colors[i])
    axes = plt.gca()
    axes.yaxis.set_ticks([r for r in range(0, 8500, 2000)])
    axes.yaxis.set_major_formatter(mtick.FuncFormatter(utils.expformat))
    axes.set_ylim(-100, 8500)
    axes.set_ylabel('# of examples', fontsize=fs)
    plt.yticks(fontsize=fs)
    axes.set_xticks(x)
    axes.set_xticklabels(labels, fontsize=fs, rotation=0)
    axes.set_xlim(0.9, 5.1)
    plt.xticks(fontsize=fs)
    axes.set_xlabel('Benware', fontsize=fs)
    plt.grid(linestyle='--')

    plt.subplot(122)
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        plt.plot(x, num_of_mal_examples[i], linestyle=line_styles[i], marker=line_makers[i], markersize=12, linewidth=6,
                 label=detection_methods_dict[det_mth], color=colors[i])

    axes = plt.gca()
    axes.yaxis.set_ticks([r for r in range(0, 8500, 2000)])
    axes.set_ylim(-100, 8500)
    axes.yaxis.set_ticklabels("")
    axes.set_xticks(x)
    axes.set_xticklabels(labels, fontsize=fs, rotation=0)
    axes.set_xlim(0.9, 5.1)
    axes.set_xlabel('Malware', fontsize=fs)
    plt.xticks(fontsize=fs)
    plt.grid(linestyle='--')
    axes.legend(loc=(-0.585, 0.535), fontsize=fs, fancybox=True)

    plt.subplots_adjust(bottom=0.01, top=0.99, left=0.08, right=0.92)
    fig_eps = plt.gcf()
    fig_eps.savefig(fig_path + '/drebin-bin-num.eps', format='pdf', dpi=800, bbox_inches='tight')
    # plt.show()


def table2():
    for det_mth, cal_mth in itertools.product(detection_methods_dict.keys(), calibration_methods_dict.keys()):
        path = get_result_path('oos', det_mth, cal_mth, exp_mode='oos')
        if not os.path.exists(path):
            logger.warning("No results of combining {} and {}: {}.".format(det_mth, cal_mth, path))
            continue
        res_pkl = utils.read_joblib(path)

        if cal_mth == 'weighted_ensemble':
            (x_prob, weights), gt_labels = res_pkl
            x_prob = np.squeeze(np.matmul(np.squeeze(x_prob, axis=-1), weights[0]), axis=-1)
        elif cal_mth == 'temperature':
            x_prob, gt_labels = res_pkl
            x_prob = np.squeeze(x_prob, axis=-1)
        else:
            x_prob, gt_labels = res_pkl
            x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)
        logger.info('Results on out of source examples from the model by combing {} and {}:'.format(det_mth, cal_mth))
        msg = ''
        y_pred = (x_prob >= 0.5).astype(np.int32)
        accuracy = accuracy_score(gt_labels, y_pred)
        baccuracy = balanced_accuracy_score(gt_labels, y_pred)
        msg += f'Accuracy: {accuracy * 100:.2f}, balanced accuracy: {baccuracy * 100:.2f} '
        tn, fp, fn, tp = confusion_matrix(gt_labels, y_pred).ravel()
        fpr = fp / float(tn + fp)
        fnr = fn / float(tp + fn)
        f1 = f1_score(gt_labels, y_pred, average='binary')
        msg += f'fpr: {fpr * 100:.2f}, fnr: {fnr * 100:.2f}, f1: {f1 * 100:.2f} | '
        _nll = nll(x_prob, gt_labels)
        _bnll = b_nll(x_prob, gt_labels)
        msg += f'NLL: {_nll:.2f}, bNLL: {_bnll:.2f} '
        _brier = brier_score(x_prob, gt_labels)
        _bbrier = b_brier_score(x_prob, gt_labels)
        msg += f'Brier score: {_brier:.2f}, bBrier score: {_bbrier:.2f} '
        _ece = expected_calibration_error(x_prob, gt_labels, bins=5)
        _uece = expected_calibration_error(x_prob, gt_labels, bins=5, use_unweighted_version=True)
        msg += f'ECE: {_ece:.3f}, uECE: {_uece:.3f}.'
        logger.info(msg)
    return


def fig3a():
    fs = 32
    line_styles = ['-.', ':', '-.', '--', '-', '-', ]
    line_markers = ['', '', '*', '', 'v', '']
    colors = sns.color_palette('deep')
    plt.figure(4, figsize=(30, 6))
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        plt.subplot(1, len(detection_methods_dict.keys()), i + 1)
        plt.title(r'{}'.format(detection_methods_dict[det_mth]), fontdict={'fontsize': fs}, fontweight="bold")
        axes = plt.gca()
        for j, cal_mth in enumerate(calibration_methods_dict.keys()):
            path = get_result_path('oos', det_mth, cal_mth, exp_mode='oos')
            res_pkl = utils.read_joblib(path)

            if cal_mth == 'weighted_ensemble':
                (x_prob, weights), gt_labels = res_pkl
                x_prob = np.squeeze(np.matmul(np.squeeze(x_prob, axis=-1), weights[0]), axis=-1)
            elif cal_mth == 'temperature':
                x_prob, gt_labels = res_pkl
                x_prob = np.squeeze(x_prob, axis=-1)
            else:
                x_prob, gt_labels = res_pkl
                x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)

            pred_entropies = entropy(x_prob)
            if i + 1 == 3:
                sns.kdeplot(pred_entropies, linestyle=line_styles[j], marker=line_markers[j],
                            markersize=6, markevery=8, linewidth=4, label=calibration_methods_dict[cal_mth], ax=axes,
                            color=colors[j])
            else:
                sns.kdeplot(pred_entropies, linestyle=line_styles[j], marker=line_markers[j],
                            markersize=6, markevery=8, linewidth=4, ax=axes,
                            color=colors[j])
            if i == 0:
                axes.set_ylabel("Density", fontsize=fs)
                # axes.set_yticklabels(rotation=0, fontsize=fs)
            else:
                axes.set_ylabel("")
                axes.yaxis.set_ticklabels("")
            axes.yaxis.set_ticks([r for r in np.arange(0, 10.1, 2)])
            axes.set_ylim(-0.1, 10.1)
            plt.yticks(fontsize=fs)
            axes.set_xlim(-0.5, 1.1)
            axes.set_xticks(np.arange(-0.5, 1.01, 0.5))
            plt.xticks(fontsize=fs)
            axes.set_xlabel('Entropy values', fontsize=fs)
            if i + 1 == 3:
                plt.legend(loc=(-0.8, 0.14), fontsize=fs - 1)
            axes.grid(linestyle='--')
    plt.savefig(fig_path + '/oos-stat-entropy.eps', format='eps', dpi=800, bbox_inches='tight')
    # plt.show()


def fig3b():
    line_styles = ['-.', ':', '-.', '--', '-', '-', ]
    line_markers = ['', '', '*', '', 'v', '']
    colors = sns.color_palette('deep')
    n_resamples = 10  # 1000 is used in the paper, yet RAM consuming
    fs = 32
    x_value = np.arange(0.01, 1.001, binwidth)
    plt.figure(4, figsize = (30, 6))
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        plt.subplot(1, len(detection_methods_dict.keys()), i + 1)
        plt.title(r'{}'.format(detection_methods_dict[det_mth]), fontdict={'fontsize': fs}, fontweight="bold")
        axes = plt.gca()
        for j, cal_mth in enumerate(calibration_methods_dict.keys()):
            path = get_result_path('oos', det_mth, cal_mth, exp_mode='oos')
            res_pkl = utils.read_joblib(path)

            if cal_mth == 'weighted_ensemble':
                (x_prob, weights), gt_labels = res_pkl
                x_prob = np.squeeze(np.matmul(np.squeeze(x_prob, axis=-1), weights[0]), axis=-1)
            elif cal_mth == 'temperature':
                x_prob, gt_labels = res_pkl
                x_prob = np.squeeze(x_prob, axis=-1)
            else:
                x_prob, gt_labels = res_pkl
                x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)
            pred_entropies = entropy(x_prob)
            low_accuracy, high_accuracy, mean_accuracy = utils.bootstrap([x_prob, pred_entropies, gt_labels],
                                                                         get_accuracy_entropy, n_resamples=n_resamples,
                                                                         seed=0)

            axes.plot(x_value, mean_accuracy.value, linestyle=line_styles[j], marker=line_markers[j],
                      markersize=6, markevery=8, linewidth=4, label=calibration_methods_dict[cal_mth], color=colors[j])
            axes.fill_between(x_value, low_accuracy.value, high_accuracy.value, color=colors[j], alpha=0.3)
            if i == 0:
                axes.set_ylabel("Accuracy on \n examples w/ " + r"entropy$\leq \tau$", fontsize=fs)
            else:
                axes.yaxis.set_ticklabels("")
            axes.yaxis.set_ticks([r for r in np.arange(0, 1.01, 0.1)])
            axes.set_ylim(0.49, 1.01)
            plt.yticks(fontsize=fs)
            axes.set_xlim(0, 1.)
            plt.xticks(fontsize=fs)
            axes.set_xlabel('Entropy ' + r'$\tau$', fontsize=fs)
            axes.grid(linestyle='--')

    plt.savefig(fig_path + '/oos-accuracy.pdf', format='pdf', dpi=800, bbox_inches='tight')
    # plt.show()


def figS7():
    fs = 20
    makers = ['v', '^', 'o', 's', 'h', '*']
    for i, det_mth in enumerate(detection_methods_dict.keys()):
        fig = plt.figure(i + 1, figsize=(12, 18))
        fig.set_rasterized(False)
        uncount = 0
        for j, cal_mth in enumerate(calibration_methods_dict.keys()):
            if cal_mth == 'vanilla' or cal_mth == 'temperature':
                uncount += 1
                continue
            sub_img_idx = j - uncount
            path = get_result_path('oos', det_mth, cal_mth, exp_mode='oos')
            res_pkl = utils.read_joblib(path)

            if cal_mth == 'weighted_ensemble':
                (_x_prob, weights), gt_labels = res_pkl
                x_prob = np.squeeze(np.matmul(np.squeeze(_x_prob, axis=-1), weights[0]), axis=-1)
                x_kld = predictive_kld(np.squeeze(_x_prob, axis=-1), number=10, w=weights[0])
                x_std = predictive_std(np.squeeze(_x_prob, axis=-1), number=10, w=weights[0])
            else:
                _x_prob, gt_labels = res_pkl
                x_prob = np.mean(np.squeeze(_x_prob, axis=-1), axis=-1)
                x_kld = predictive_kld(np.squeeze(_x_prob, axis=-1), number=10)
                x_std = predictive_std(np.squeeze(_x_prob, axis=-1), number=10)
            pred_entropies = entropy(x_prob)
            plt.subplot(4, 2, 2 * sub_img_idx + 1)
            plt.title(r'{}'.format(calibration_methods_dict[cal_mth]), fontdict={'fontsize': fs}, fontweight="bold")
            plt.scatter(pred_entropies, x_kld, color='grey', marker=makers[j], s=2, alpha=0.7)
            axes = plt.gca()
            axes.set_ylabel(r'KL divergence', fontsize=fs)
            plt.yticks(fontsize=fs)
            axes.set_ylim(-0.01, 0.91)
            if sub_img_idx == 3:
                axes.set_xlabel(r'Entropy', fontsize=fs)
                # axes.xaxis.set_ticklabels([0, 0.2, 0.4, 0.6, 0.8, 1.])
            else:
                axes.xaxis.set_ticklabels("")
            plt.xticks(fontsize=fs)
            axes.set_xlim(-0.01, 1.01)

            plt.subplot(4, 2, 2 * sub_img_idx + 2)
            plt.title(r'{}'.format(calibration_methods_dict[cal_mth]), fontdict={'fontsize': fs}, fontweight="bold")
            plt.scatter(pred_entropies, x_std, color='black', marker=makers[j], s=2)
            axes = plt.gca()
            axes.set_ylabel(r'Standard deviation', fontsize=fs)
            plt.yticks(fontsize=fs)
            if sub_img_idx == 3:
                axes.set_xlabel(r'Entropy', fontsize=fs)
            else:
                axes.xaxis.set_ticklabels("")

            plt.xticks(fontsize=fs)
            axes.set_ylim(-0.01, 0.91)
            axes.set_xlim(-0.01, 1.01)
        plt.subplots_adjust(bottom=0.1, top=0.9, left=0.08, right=0.92)
        pltsave = plt.gcf()
        pltsave.savefig(fig_path + "/drebin-{}-entropy-kl-std.pdf".format(det_mth), format='pdf', dpi=400, bbox_inches='tight')
        # plt.show()

    return




def get_prob_androzoo(path, detection_method, calibration_method, idx):
    intermediate_data_save_path = config.get('androzoo_tesseract', 'intermediate_directory')
    _1, _2, _3, _4, _5, _6, iid_test_y, de_test_y, _7, _8 = utils.read_joblib(os.path.join(intermediate_data_save_path,
                                                                                           'androzoo_database.{}'.format(detection_method)))
    res_pkl = utils.read_joblib(path)
    if calibration_method == 'weighted_ensemble':
        x_prob, weights = res_pkl[idx]
        x_prob = np.clip(np.squeeze(np.matmul(np.squeeze(x_prob, axis = -1), weights)), 0., 1.)
    elif calibration_method == 'temperature':
        x_prob = res_pkl[idx]
        x_prob = np.squeeze(x_prob, axis=-1)
    else:
        x_prob = res_pkl[idx]
        x_prob = np.mean(np.squeeze(x_prob, axis=-1), axis=-1)

    if idx == 0:
        gt_labels = iid_test_y
    else:
        gt_labels = de_test_y[idx - 1]
    assert gt_labels.shape[0] == x_prob.shape[0]
    return x_prob, gt_labels


def fig4():
    line_styles = ['-.', ':', '-.', '--', '-', '-', ]
    line_markers = ['', '', '*', '', 'v', '']
    colors = sns.color_palette('deep')
    N = 24
    drange = [d.strftime('%Y-%m') for d in pd.date_range("2015-01", periods=N, freq="MS")]
    x_value = np.array([x for x in range(25)])
    x_ticks = x_value[::2]
    x_ticks_label = [r'Test set'] + [r'{}'.format(t) for t in drange[1::2]]
    fs = 16
    n_resamples = 10  # 1000 is used in the paper, yet RAM consuming
    for i in range(len(detection_methods_dict.keys())):
        if i + 2 >= 3:
            break
        mth1 = list(detection_methods_dict.keys())[i]
        mth2 = list(detection_methods_dict.keys())[i + 1]
        mth3 = list(detection_methods_dict.keys())[i + 2]
        fig = plt.figure(i % 3 + 1, figsize=(15, 6))

        def draw_01(det_mth, axes, use_y_label):
            for j, cal_mth in enumerate(calibration_methods_dict.keys()):
                low, high, mean = [], [], []
                for k in range(25):
                    path = get_result_path('androzoo_tesseract', det_mth, cal_mth, 'test')
                    x_prob, gt_labels = get_prob_androzoo(path, det_mth, cal_mth, k)
                    y_pred = (x_prob >= 0.5).astype(np.int32)
                    e_l, e_h, e_m = utils.bootstrap([gt_labels, y_pred], balanced_accuracy_score, n_resamples=n_resamples, seed=0)
                    low.append(e_l.value)
                    high.append(e_h.value)
                    mean.append(e_m.value)
                line_label = calibration_methods_dict[cal_mth]
                axes.plot(x_value, mean, linestyle=line_styles[j], linewidth=2,
                          marker=line_markers[j], markersize=4, markevery=8,
                          label=line_label, color=colors[j])
                axes.fill_between(x_value, low, high, color=colors[j], alpha=0.2)

            axes.set_title(r'{}'.format(detection_methods_dict[det_mth]),
                           fontsize=fs, fontweight="bold")

            axes.yaxis.set_ticks([r for r in np.arange(0.5, 1.01, 0.1)])
            axes.set_ylim(0.5, 1)
            y_tl = ['{:.2f}'.format(r) for r in np.arange(0.5, 1.01, 0.1)]
            axes.yaxis.set_ticklabels(y_tl, fontsize=fs)
            axes.set_xticks(x_ticks)
            axes.set_xlim(-0.2, 24.2)
            axes.xaxis.set_ticklabels('')
            axes.grid(linestyle='--', color='k', alpha=0.3)
            axes.yaxis.set_ticklabels(y_tl, fontsize=fs)

            if use_y_label:
                axes.set_ylabel(r'bAcc', fontsize=fs)
            else:
                axes.set_ylabel(r'')
                axes.yaxis.set_ticklabels('')

        plt.subplot(3, 3, 3 * i + 1)
        axes = plt.gca()
        draw_01(mth1, axes, use_y_label=True)

        plt.subplot(3, 3, 3 * i + 2)
        axes_2 = plt.gca()
        draw_01(mth2, axes_2, use_y_label=False)

        plt.subplot(3, 3, 3 * i + 3)
        axes_3 = plt.gca()
        draw_01(mth3, axes_3, use_y_label=False)

        def draw_02(det_mth, axes2, use_y_label):
            for j, cal_mth in enumerate(calibration_methods_dict.keys()):
                low, high, mean = [], [], []
                for k in range(25):
                    path = get_result_path('androzoo_tesseract', det_mth, cal_mth, 'test')
                    x_prob, gt_labels = get_prob_androzoo(path, det_mth, cal_mth, k)
                    e_l, e_h, e_m = utils.bootstrap([x_prob, gt_labels], b_nll, n_resamples=n_resamples,
                                                    seed=0)
                    low.append(e_l.value)
                    high.append(e_h.value)
                    mean.append(e_m.value)
                line_label = calibration_methods_dict[cal_mth]
                if j < 3:
                    line_label = ''
                axes2.plot(x_value, mean, linestyle=line_styles[j], linewidth=2,
                           marker=line_markers[j], markersize=4, markevery=8,
                           label=line_label,
                           color=colors[j])

                axes2.fill_between(x_value, low, high, color=colors[j], alpha=0.2)

            axes2.yaxis.set_ticks([r for r in np.arange(0, 10.1, 2.)])
            y_tl2 = [r for r in np.arange(0, 10.1, 2.)]
            axes2.set_ylim(0.0, 10)
            # plt.yticks(fontsize = fs)
            axes2.yaxis.set_ticklabels(y_tl2, fontsize=fs)
            axes2.set_xticks(x_ticks)
            axes2.set_xlim(-0.2, 24.2)
            axes2.xaxis.set_ticklabels('')
            axes2.grid(linestyle='--', color='k', alpha=0.3)
            axes2.yaxis.set_ticklabels(y_tl2, fontsize=fs)

            if use_y_label:
                axes2.set_ylabel(r'bNLL', fontsize=fs)
            else:
                axes2.set_ylabel(r'')
                axes2.yaxis.set_ticklabels('')

        plt.subplot(3, 3, 3 * i + 4)
        axes2_0 = plt.gca()
        draw_02(mth1, axes2_0, use_y_label=True)

        plt.subplot(3, 3, 3 * i + 5)
        axes2_1 = plt.gca()
        draw_02(mth2, axes2_1, use_y_label=False)

        plt.subplot(3, 3, 3 * i + 6)
        axes2_2 = plt.gca()
        draw_02(mth3, axes2_2, use_y_label=False)

        def draw_03(det_mth, axes3, use_y_label):
            for j, cal_mth in enumerate(calibration_methods_dict.keys()):
                low, high, mean = [], [], []
                for k in range(25):
                    path = get_result_path('androzoo_tesseract', det_mth, cal_mth, 'test')
                    x_prob, gt_labels = get_prob_androzoo(path, det_mth, cal_mth, k)
                    e_l, e_h, e_m = utils.bootstrap([x_prob, gt_labels], b_brier_score, n_resamples=n_resamples,
                                                    seed=0)
                    low.append(e_l.value)
                    high.append(e_h.value)
                    mean.append(e_m.value)
                line_label = calibration_methods_dict[cal_mth]
                if j >= 3:
                    line_label = ''
                axes3.plot(x_value, mean, linestyle=line_styles[j], linewidth=2,
                           marker=line_markers[j], markersize=4, markevery=8,
                           label=line_label, color=colors[j])

                axes3.fill_between(x_value, low, high, color=colors[j], alpha=0.2)

                axes3.yaxis.set_ticks([r for r in np.arange(0, 0.51, 0.1)])
                y_tl3 = ['{:.2f}'.format(r) for r in np.arange(0, 0.51, 0.1)]
                axes3.set_ylim(0.0, 0.51)
                axes3.set_xticks(x_ticks)
                axes3.xaxis.set_ticklabels(x_ticks_label, rotation=90, fontsize=fs)
                axes3.set_xlim(-0.2, 24.2)
                axes3.grid(linestyle='--', color='k', alpha=0.3)
                axes3.yaxis.set_ticklabels(y_tl3, fontsize=fs)

                if use_y_label:
                    axes3.set_ylabel(r'bBrier', fontsize=fs)
                else:
                    axes3.set_ylabel(r'')
                    axes3.yaxis.set_ticklabels('')

        plt.subplot(3, 3, 3 * i + 7)
        axes3_0 = plt.gca()
        draw_03(mth1, axes3_0, use_y_label=True)
        plt.subplot(3, 3, 3 * i + 8)
        axes3_1 = plt.gca()
        draw_03(mth2, axes3_1, use_y_label=False)
        plt.subplot(3, 3, 3 * i + 9)
        axes3_2 = plt.gca()
        draw_03(mth3, axes3_2, use_y_label=False)

        axes3_1.legend(loc=(0.01, 1.6), fontsize=fs, borderaxespad=2.)
        axes2_2.legend(loc=(0.01, 0.38), fontsize=fs, borderaxespad=2.)
        plt.subplots_adjust(wspace=0.08)
        fig.subplots_adjust(bottom=0.34, top=0.95, left=0.11, right=0.9)
        pltsave = plt.gcf()
        pltsave.savefig(fig_path + "/androzoo_b_acc_nll_brier_{}.pdf".format(i), format='pdf', dpi=800, bbox_inches='tight')
        plt.show()


def table3():
    for det_mth, cal_mth in itertools.product(detection_methods_dict.keys(), calibration_methods_dict.keys()):
        path = get_result_path('adv', det_mth, cal_mth, exp_mode='adv')
        if not os.path.exists(path):
            logger.warning("No results of combining {} and {}: {}.".format(det_mth, cal_mth, path))
            continue
        res_pkl = utils.read_joblib(path)

        if cal_mth == 'weighted_ensemble':
            prist_results, adv_results, prist_y, adv_y = res_pkl
            (prist_prob, prist_weights) = prist_results
            (adv_prob, adv_weights) = adv_results
            prist_prob = np.squeeze(np.matmul(np.squeeze(prist_prob, axis=-1), prist_weights[0]))
            adv_prob = np.squeeze(np.matmul(np.squeeze(adv_prob, axis=-1), adv_weights[0]))
        elif cal_mth == 'temperature':
            prist_prob, adv_prob, prist_y, adv_y = res_pkl
            prist_prob = np.squeeze(prist_prob, axis=-1)
            adv_prob = np.squeeze(adv_prob, axis=-1)
        else:
            prist_prob, adv_prob, prist_y, adv_y = res_pkl
            prist_prob = np.mean(np.squeeze(prist_prob, axis=-1), axis=-1)
            adv_prob = np.mean(np.squeeze(adv_prob, axis=-1), axis=-1)

        logger.info('Results on out of source examples from the model by combing {} and {}:'.format(det_mth, cal_mth))
        msg = 'No attack: '
        prist_y_pred = (prist_prob >= 0.5).astype(np.int32)
        accuracy = accuracy_score(prist_y, prist_y_pred)
        msg += f'Accuracy: {accuracy * 100:.2f} '
        _nll = nll(prist_prob, prist_y)
        msg += f'NLL: {_nll:.2f} '
        _brier = brier_score(prist_prob, prist_y)
        msg += f'Brier score: {_brier:.2f}.\n'

        msg += 'Max pgds+gdkde attack: '
        adv_y_pred = (adv_prob >= 0.5).astype(np.int32)
        accuracy = accuracy_score(adv_y, adv_y_pred)
        msg += f'Accuracy: {accuracy * 100:.2f} '
        _nll = nll(adv_prob, adv_y)
        msg += f'NLL: {_nll:.2f} '
        _brier = brier_score(adv_prob, adv_y)
        msg += f'Brier score: {_brier:.2f}.\n'
        logger.info(msg)
    return


def _main():
    table1()
    fig2a()
    fig2b()
    table2()
    fig3a()
    fig3b()
    figS7()
    fig4()
    table3()


if __name__ == '__main__':
    _main()
